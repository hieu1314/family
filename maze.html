    <!DOCTYPE html>
    <html lang="en">
    <head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Maze Auto-move Final</title>
    <style>
  html, body {
            margin:0; padding:0; height:100%; overflow:hidden;
            background:#000;
            display:flex;
            flex-direction:column;
            align-items:center;
            justify-content:flex-start;
            color:#fff;
            font-family:sans-serif;
        }
        body { touch-action: none; }
        canvas {
            width: 90vw;
            height: auto;
            max-width: 744px;
        }
        canvas {
            display:block;
            background:#000;
            margin-top:10px;
        }

        #title {
            font-size:24px;
            font-weight:bold;
            margin-top:10px;
        }
        #timer {
            font-size:20px;
            margin-top:4px;
        }
  #winMessage, #loseMessage {
    font-size: 32px;
    font-weight: bold;
    text-align: center;
    text-shadow: 0 0 10px #000;
    background: rgba(0,0,0,0.75);
    padding: 20px 30px;
    border-radius: 14px;
    position: fixed;
    top: 40%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 2000;
}

#winMessage {
    color: #00ff9c;
    text-shadow: 0 0 12px #00ff9c;
}

#loseMessage {
    color: #ff4444;
    text-shadow: 0 0 12px #ff0000;
}

#controls {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    align-items: center;
    gap: 20px; /* kho·∫£ng c√°ch gi·ªØa D-pad v√† n√∫t ‚ü≥ */
    z-index: 1000;
}

/* D-pad 3x3 */
#dpad {
    display: grid;
    grid-template-columns: 60px 60px 60px;
    grid-template-rows: 60px 60px 60px;
    gap: 10px; /* kho·∫£ng tr·ªëng gi·ªØa c√°c n√∫t */
}

/* Kho·∫£ng tr·ªëng ·ªü gi·ªØa */
.center-gap {
    width: 60px;
    height: 60px;
}

/* N√∫t chung */
#dpad button,
#undoBtn {
    width: 60px;
    height: 60px;
    font-size: 30px;
    background-color: #333;
    color: white;
    border: none;
    border-radius: 50%;
    cursor: pointer;
}

#dpad button:hover,
#undoBtn:hover {
    background-color: #555;
}

/* ·∫®n tr√™n PC */
@media (min-width: 769px) {
    #controls {
        display: none;
    }
}
/* PC: ch·ªâ hi·ªán n√∫t ‚ü≥ */
@media (min-width: 769px) {
    #controls {
        display: flex;
        bottom: 20px;
        left: auto;
        right: 20px;
        transform: none;
    }

    #dpad {
        display: none; /* ·∫®n 4 n√∫t di chuy·ªÉn */
    }

    #undoBtn {
        position: static;
    }
}
    </style>
    </head>

    <body>
    <div id="title">H√£y ki√™n nh·∫´n v√† c·∫ßu may</div>
    <div id="timer">Time: 90</div>
    <canvas id="mazeCanvas"></canvas>
  
    <div id="winMessage" style="display:none;">
    üéâ Ch√∫c m·ª´ng h·∫øt m√™ m·ª•i! üéâ
</div>

<div id="loseMessage" style="display:none;">
    üíÄ B·∫°n ƒë√£ h·∫øt th·ªùi gian! üíÄ
</div>
 <!-- C√°c n√∫t di chuy·ªÉn (hi·ªÉn th·ªã ch·ªâ tr√™n mobile) -->
    <div id="controls">
  <div id="dpad">
    <div></div>
    <button id="upBtn">‚Üë</button>
    <div></div>

    <button id="leftBtn">‚Üê</button>
    <div class="center-gap"></div>
    <button id="rightBtn">‚Üí</button>

    <div></div>
    <button id="downBtn">‚Üì</button>
    <div></div>
  </div>

  <button id="undoBtn">‚ü≥</button>
</div>

    <script>
    const canvas = document.getElementById("mazeCanvas");
    const ctx = canvas.getContext("2d");

    const ROWS = 33;
    const COLS = 33;
    const TILE = 24;
    canvas.width = COLS * TILE;
    canvas.height = ROWS * TILE;

    let maze = [];
    let player = {x:0, y:0};
    let exit = {x:COLS-1, y:ROWS-1};
    let prevPos = null;
    let revealExit = true;
    let timerEl = document.getElementById("timer");
    let messageEl = document.getElementById("message");

    let timeLeft = 90; // 90 gi√¢y
    let timerInterval;
let timerStarted = false;
let revealAll = false;

// === CH·ªêNG D√çNH 2 √î ===
function countOpenNeighbors(x,y){
    let c = 0;
    for(let [dx,dy] of [[0,-1],[1,0],[0,1],[-1,0]]){
        let nx = x+dx, ny = y+dy;
        if(inBounds(nx,ny) && maze[ny][nx]===0) c++;
    }
    return c;
}
// === N·ªêI DEAD-END G·∫¶N EXIT V√ÄO NH√ÅNH GI·∫¢ ===
function connectLonelyNearExit(){
    const MAX_DIST = 5;
    let candidates = [];

    for(let y=exit.y-MAX_DIST; y<=exit.y+MAX_DIST; y++){
        for(let x=exit.x-MAX_DIST; x<=exit.x+MAX_DIST; x++){
            if(!inBounds(x,y)) continue;
            if(maze[y][x]!==0) continue;

            if(countOpenNeighbors(x,y) !== 1) continue; // ch·ªâ dead-end th·∫≠t

            // ‚≠ê ki·ªÉm tra: n·∫øu dead-end ngay s√°t exit, b·ªè qua
            if(Math.abs(x-exit.x)+Math.abs(y-exit.y) <= 2) continue;

            candidates.push({x,y});
        }
    }

    if(!candidates.length) return;

    let dead = shuffle(candidates)[0];

    for(let [dx,dy] of shuffle([[0,-1],[1,0],[0,1],[-1,0]])){
        let bx = dead.x + dx*2;
        let by = dead.y + dy*2;

        if(!inBounds(bx,by)) continue;
        if(maze[by][bx]!==0) continue;

        // tr√°nh ƒë·ª•ng exit tr·ª±c ti·∫øp
        if(Math.abs(bx-exit.x)+Math.abs(by-exit.y) <= 1) continue;

        if(countOpenNeighbors(dead.x+dx, dead.y+dy)===0){
            maze[dead.y+dy][dead.x+dx] = 0;
            break;
        }
    }
}

    /* ===== MAZE GEN ===== */
    function initMaze() {
    // B∆∞·ªõc 1: Kh·ªüi t·∫°o m√™ cung ban ƒë·∫ßu
    maze = Array.from({ length: ROWS }, () => Array(COLS).fill(1));

  
   exit = getFixedExit();
    player = {x:0,y:0};

    carveMainPath(0,0);
    addDeadEnds();

 // ==== N·ªêI NH√ÅNH GI·∫¢ TR·ª∞C TI·∫æP V√ÄO ƒê∆Ø·ªúNG CH√çNH ====
 let mainPath = getPathFromStartToExit();
if(mainPath.length >= 6){
    let fractions = [1/52, 2/52, 2/26, 3/26, 4/26, 3/13, 4/13, 5/13, 5/10, 6/10, 7/10, 8/10];
    let indices = fractions.map(f => Math.floor(mainPath.length * f));

    for(let idx of indices){
        let p = mainPath[idx];

        // ‚úÖ tr√°nh n·ªëi qu√° g·∫ßn exit (v√≠ d·ª• c√°ch exit < 4 √¥)
        let distToExit = Math.abs(p.x - exit.x) + Math.abs(p.y - exit.y);
        if(distToExit < 6) continue; 

        // t√¨m √¥ nh√°nh gi·∫£ dead-end xung quanh
        let neighbors = shuffle([[0,-1],[1,0],[0,1],[-1,0]]);
        for(let [dx,dy] of neighbors){
            let nx = p.x + dx;
            let ny = p.y + dy;
            if(!inBounds(nx,ny)) continue;
            if(maze[ny][nx] !== 0) continue; // ph·∫£i l√† nh√°nh gi·∫£
            if(countOpenNeighbors(nx,ny) !== 1) continue; // dead-end th·∫≠t

            // ƒë·ª•c 1 √¥ n·ªëi nh√°nh gi·∫£ v√†o ƒë∆∞·ªùng ch√≠nh
            maze[p.y + dy][p.x + dx] = 0;
            break; // m·ªói v·ªã tr√≠ ch·ªâ n·ªëi 1 nh√°nh
        }
    }
}
    // ==== N·ªêI NH√ÅNH GI·∫¢ V√ÄO ƒê∆Ø·ªúNG CH√çNH ====
    connectFakeBranchesAlongMainPath();
    breakWallsNearFakeBranches();

// üî• QUAN TR·ªåNG
sealExit();

connectLonelyNearExit();
ensureExitReachable_FarthestFromExit();
     // ƒë·∫£m b·∫£o l·ªëi ra cho player
    maze[0][0] = 0;
    maze[0][1] = 0;
    maze[1][0] = 0;

    maze[exit.y][exit.x] = 0;

 // ‚úÖ CH·ªñ N√ÄY: fix t·∫•t c·∫£ v√πng c√¥ l·∫≠p
    let safety = 300;
   while(safety--){
        let fixed = ensureAllPathsReachable();
        if(!fixed) break;

        // ph√° b·ªõt t∆∞·ªùng d√†i > 20
        for(let y=1;y<ROWS-1;y++){
            for(let x=1;x<COLS-1;x++){
                if(maze[y][x] === 1){
                    let len = 0;
                    for(let k=x;k<COLS-1 && maze[y][k]===1;k++) len++;
                    if(len > 12) maze[y][x+Math.floor(len/2)] = 0;
                }
            }
        }
    }
fixAllIsolatedPaths();
    drawMaze();
}
 function getFixedExit(){
    return {
        x: COLS - 3, // c√°ch t∆∞·ªùng ph·∫£i 2 √¥
        y: ROWS - 3  // c√°ch t∆∞·ªùng d∆∞·ªõi 2 √¥
    };
}
function shuffle(arr){
    return arr.sort(()=>Math.random()-0.5);
}

function inBounds(x,y){
    return x>=0 && y>=0 && x<COLS && y<ROWS;
}
function carveMainPath(x, y, depth = 0){
    maze[y][x] = 0;

    let dirs = shuffle([
        [0,-1],[1,0],[0,1],[-1,0]
    ]);

    for(let [dx,dy] of dirs){
        let nx = x + dx*2;
        let ny = y + dy*2;

        if(!inBounds(nx,ny)) continue;
        if(maze[ny][nx] === 0) continue;

        // ‚ùå tr√°nh ƒë√†o th·∫≥ng v·ªÅ exit s·ªõm
        let distToExit = Math.abs(nx-exit.x)+Math.abs(ny-exit.y);
        if(distToExit < 10 && depth < 20) continue;

        maze[y+dy][x+dx] = 0;
        carveMainPath(nx,ny,depth+1);
    }
}
function carveDeadEnd(x,y,length=9){
    length = Math.min(length, 12); // tr√°nh qu√° d√†i
    let cx=x, cy=y;
    let dir = shuffle([[0,-1],[1,0],[0,1],[-1,0]])[0];

    for(let i=0;i<length;i++){
        let nx=cx+dir[0]*2;
        let ny=cy+dir[1]*2;

        if(!inBounds(nx,ny) || maze[ny][nx]===0) break;
        if(countOpenNeighbors(nx,ny) > 1) break; // ‚≠ê CH·ªêNG D√çNH

        maze[cy+dir[1]][cx+dir[0]] = 0;
        maze[ny][nx] = 0;

        cx=nx; cy=ny;
    }
}

function addDeadEnds(){
    for(let y=1;y<ROWS;y+=2){
        for(let x=1;x<COLS;x+=2){
            if(maze[y][x]===0 && Math.random()<0.35){
                carveDeadEnd(x,y,9+Math.floor(Math.random()*4));
            }
        }
    }
}
function sealExit() {
    let ex = exit.x;
    let ey = exit.y;
    const neighbors = [[0,-1], [1,0], [0,1], [-1,0]];

    // 1Ô∏è‚É£ ƒê·∫∑t t∆∞·ªùng 1 √¥ quanh exit
    for (let [dx, dy] of neighbors) {
        let x = ex + dx;
        let y = ey + dy;
        if (inBounds(x, y)) maze[y][x] = 1;
    }

    // 2Ô∏è‚É£ T·∫°o l·ªëi d·∫´n v√†o exit √≠t nh·∫•t 4 √¥, quanh co
    const minLength = 4;
    let pathMade = false;
    let attempts = 0;

    while (!pathMade && attempts < 20) { // gi·ªõi h·∫°n s·ªë l·∫ßn th·ª≠ tr√°nh loop v√¥ h·∫°n
        attempts++;
        // Ch·ªçn h∆∞·ªõng ch√≠nh ng·∫´u nhi√™n
        let [dx, dy] = neighbors[Math.floor(Math.random() * neighbors.length)];
        let length = minLength + Math.floor(Math.random() * 3); // d√†i 4~6 √¥

        let x = ex;
        let y = ey;
        let valid = true;
        let positions = [];

        for (let i = 1; i <= length; i++) {
            x += dx;
            y += dy;
            // C√≥ th·ªÉ th√™m "quanh co" ng·∫´u nhi√™n
            if (Math.random() < 0.3) {
                let turn = neighbors[Math.floor(Math.random() * neighbors.length)];
                x += turn[0];
                y += turn[1];
            }

            if (!inBounds(x, y) || maze[y][x] !== 1) {
                valid = false;
                break;
            }
            positions.push([x, y]);
        }

        if (valid) {
            for (let [px, py] of positions) maze[py][px] = 0;
            maze[ey][ex] = 0;
            pathMade = true;
        }
    }

    // 3Ô∏è‚É£ B·∫£o hi·ªÉm exit lu√¥n m·ªü
    maze[exit.y][exit.x] = 0;
}

function createFakeDeadEnd(sx, sy, length){
    length = Math.min(length, 8); // nh√°nh gi·∫£ ng·∫Øn
    const dirs = shuffle([[0,-1],[1,0],[0,1],[-1,0]]);

    for(let [dx,dy] of dirs){
        let bx = sx + dx*2;
        let by = sy + dy*2;

        if(!inBounds(bx,by)) continue;
        if(maze[by][bx]===0) continue;
        if(countOpenNeighbors(bx,by)>0) continue;

        // ‚≠ê ch·ªâ 1 choke point
        maze[sy+dy][sx+dx] = 0;
        maze[by][bx] = 0;

        let cx=bx, cy=by;
        for(let i=0;i<length;i++){
            let d2 = shuffle([[0,-1],[1,0],[0,1],[-1,0]])[0];
            let nx=cx+d2[0]*2;
            let ny=cy+d2[1]*2;

            if(!inBounds(nx,ny)) break;
            if(maze[ny][nx]===0) break;
            if(countOpenNeighbors(nx,ny)>1) break;

            maze[cy+d2[1]][cx+d2[0]] = 0;
            maze[ny][nx] = 0;
            cx=nx; cy=ny;
        }
        break; // ‚ùó ch·ªâ 1 nh√°nh
    }
}

// H√†m l·∫•y m·∫£ng c√°c √¥ ƒë∆∞·ªùng ch√≠nh t·ª´ player ‚Üí exit
function getPathFromStartToExit(){
    // BFS ho·∫∑c DFS ƒë·ªÉ t√¨m 1 ƒë∆∞·ªùng ƒë∆°n gi·∫£n t·ª´ start ‚Üí exit
    let queue = [{x:0,y:0,path:[{x:0,y:0}]}];
    let visited = Array.from({length:ROWS},()=>Array(COLS).fill(false));
    visited[0][0]=true;

    while(queue.length){
        let curr = queue.shift();
        if(curr.x===exit.x && curr.y===exit.y) return curr.path;

        for(let [dx,dy] of [[0,-1],[1,0],[0,1],[-1,0]]){
            let nx = curr.x + dx;
            let ny = curr.y + dy;
            if(!inBounds(nx,ny)) continue;
            if(maze[ny][nx]!==0) continue;
            if(visited[ny][nx]) continue;
            visited[ny][nx]=true;
            queue.push({x:nx,y:ny,path:[...curr.path,{x:nx,y:ny}]});
        }
    }
    return [{x:0,y:0}]; // fallback
}

function getReachableFromPlayer(){
    let visited = Array.from({length: ROWS}, () => Array(COLS).fill(false));
    let stack = [{x:0,y:0}];
    visited[0][0] = true;

    while(stack.length){
        let {x,y} = stack.pop();
        for(let [dx,dy] of [[0,-1],[1,0],[0,1],[-1,0]]){
            let nx = x+dx, ny = y+dy;
            if(
                inBounds(nx,ny) &&
                !visited[ny][nx] &&
                maze[ny][nx] === 0
            ){
                visited[ny][nx] = true;
                stack.push({x:nx,y:ny});
            }
        }
    }
    return visited;
}

function ensureExitReachable_FarthestFromExit(){
    let reachable = getReachableFromPlayer();

    // ‚úÖ ƒê√£ ƒëi ƒë∆∞·ª£c r·ªìi ‚Üí th√¥i
    if(reachable[exit.y][exit.x]) return;

    // ‚úÖ Nh√¨n / ƒëi th·∫≥ng ƒë∆∞·ª£c ‚Üí th√¥i
    if(hasClearPathToExit()) return;

    let best = null;
    let bestDist = -1;

    for(let y=1; y<ROWS-1; y++){
        for(let x=1; x<COLS-1; x++){
            if(maze[y][x] !== 1) continue;

            let hasReachable = false;
            let hasUnreachable = false;

            for(let [dx,dy] of [[0,-1],[1,0],[0,1],[-1,0]]){
                let nx = x+dx, ny = y+dy;
                if(!inBounds(nx,ny)) continue;
                if(maze[ny][nx] !== 0) continue;

                if(reachable[ny][nx]) hasReachable = true;
                else hasUnreachable = true;
            }

            if(hasReachable && hasUnreachable){
                let dist = Math.abs(x-exit.x) + Math.abs(y-exit.y);
                if(dist > bestDist){
                    bestDist = dist;
                    best = {x,y};
                }
            }
        }
    }

    if(best){
        maze[best.y][best.x] = 0; // ‚≠ê ch·ªâ l√∫c TH·∫¨T S·ª∞ C·∫¶N
    }
}

function hasClearPathToExit(){
    let x = 0, y = 0;

    // ƒëi ngang tr∆∞·ªõc
    let stepX = exit.x > x ? 1 : -1;
    while(x !== exit.x){
        if(maze[y][x] === 1) return false;
        x += stepX;
    }

    // r·ªìi ƒëi d·ªçc
    let stepY = exit.y > y ? 1 : -1;
    while(y !== exit.y){
        if(maze[y][x] === 1) return false;
        y += stepY;
    }

    return true;
}

function ensureAllPathsReachable(){
    let reachable = getReachableFromPlayer();
    let regions = getUnreachableRegions(reachable);
    if(!regions.length) return false;

    // 1Ô∏è‚É£ ch·ªçn v√πng ch·∫øt xa exit nh·∫•t
    let bestRegion = null;
    let bestRegionDist = -1;

    for(let region of regions){
        let minDist = Infinity;
        for(let c of region){
            let d = Math.abs(c.x-exit.x) + Math.abs(c.y-exit.y);
            if(d < minDist) minDist = d;
        }
        if(minDist > bestRegionDist){
            bestRegionDist = minDist;
            bestRegion = region;
        }
    }

    // s·ªë √¥ reachable hi·ªán t·∫°i
    let beforeCount = 0;
    for(let y=0;y<ROWS;y++)
        for(let x=0;x<COLS;x++)
            if(reachable[y][x]) beforeCount++;

    let bestWall = null;
    let bestWallDist = -1;

    // 2Ô∏è‚É£ th·ª≠ T·∫§T C·∫¢ t∆∞·ªùng bi√™n c·ªßa v√πng ƒë√≥
    for(let c of bestRegion){
        for(let [dx,dy] of [[0,-1],[1,0],[0,1],[-1,0]]){
            let wx = c.x+dx;
            let wy = c.y+dy;
            let rx = c.x-dx;
            let ry = c.y-dy;

            if(!inBounds(wx,wy) || !inBounds(rx,ry)) continue;
            if(maze[wy][wx]!==1) continue;
            if(!reachable[ry][rx]) continue;

            // üî¨ gi·∫£ l·∫≠p ƒë·ª•c
            maze[wy][wx] = 0;
            let testReachable = getReachableFromPlayer();

            let afterCount = 0;
            for(let y=0;y<ROWS;y++)
                for(let x=0;x<COLS;x++)
                    if(testReachable[y][x]) afterCount++;

            // ho√†n t√°c
            maze[wy][wx] = 1;

            // ‚ùå ƒë·ª•c v√¥ nghƒ©a
            if(afterCount <= beforeCount) continue;

            // ‚úÖ ƒë·ª•c c√≥ hi·ªáu qu·∫£
            let dist = Math.abs(wx-exit.x)+Math.abs(wy-exit.y);
            if(dist > bestWallDist){
                bestWallDist = dist;
                bestWall = {x:wx,y:wy};
            }
        }
    }

    // 3Ô∏è‚É£ ch·ªâ ƒë·ª•c khi ch·∫Øc ch·∫Øn n·ªëi v·ªÅ player
    if(bestWall){
        maze[bestWall.y][bestWall.x] = 0;
        return true;
    }

    return false;
}

function getUnreachableRegions(reachable){
    let visited = Array.from({length:ROWS},()=>Array(COLS).fill(false));
    let regions = [];

    for(let y=1;y<ROWS-1;y++){
        for(let x=1;x<COLS-1;x++){
            if(maze[y][x]!==0) continue;
            if(reachable[y][x]) continue;
            if(visited[y][x]) continue;

            let stack=[{x,y}];
            let cells=[];
            visited[y][x]=true;

            while(stack.length){
                let {x,y}=stack.pop();
                cells.push({x,y});

                for(let [dx,dy] of [[0,-1],[1,0],[0,1],[-1,0]]){
                    let nx=x+dx, ny=y+dy;
                    if(!inBounds(nx,ny)) continue;
                    if(visited[ny][nx]) continue;
                    if(maze[ny][nx]!==0) continue;
                    if(reachable[ny][nx]) continue;

                    visited[ny][nx]=true;
                    stack.push({x:nx,y:ny});
                }
            }

            regions.push(cells);
        }
    }
    return regions;
}

function fixAllIsolatedPaths(){
    let safety = 100; // d∆∞ r·∫•t nhi·ªÅu cho 33x33

    while(safety--){

        let reachable = getReachableFromPlayer();
        let hasIsolated = false;

        // ki·ªÉm tra c√≤n √¥ 0 n√†o unreachable kh√¥ng
        for(let y=0;y<ROWS;y++){
            for(let x=0;x<COLS;x++){
                if(maze[y][x] === 0 && !reachable[y][x]){
                    hasIsolated = true;
                    break;
                }
            }
            if(hasIsolated) break;
        }

        // ‚úÖ s·∫°ch ho√†n to√†n
        if(!hasIsolated) return;

        let bestWall = null;
        let bestDist = -1;

        // t√¨m t∆∞·ªùng n·ªëi reachable <-> unreachable
        for(let y=1;y<ROWS-1;y++){
            for(let x=1;x<COLS-1;x++){
                if(maze[y][x] !== 1) continue;

                let r = false, u = false;

                for(let [dx,dy] of [[0,-1],[1,0],[0,1],[-1,0]]){
                    let nx = x+dx, ny = y+dy;
                    if(!inBounds(nx,ny)) continue;
                    if(maze[ny][nx] !== 0) continue;

                    if(reachable[ny][nx]) r = true;
                    else u = true;
                }

                if(r && u){
                    let d = Math.abs(x-exit.x) + Math.abs(y-exit.y);
                    if(d > bestDist){
                        bestDist = d;
                        bestWall = {x,y};
                    }
                }
            }
        }

        // üö® kh√¥ng c√≤n t∆∞·ªùng h·ª£p l·ªá (hi·∫øm, nh∆∞ng an to√†n)
        if(!bestWall){
            console.warn("FIX FAILED: still isolated paths");
            return;
        }

        // üî• ƒë·ª•c 1 √¥
        maze[bestWall.y][bestWall.x] = 0;
    }

    console.warn("FIX SAFETY LIMIT HIT");
}
 
function connectFakeBranchesAlongMainPath() {
    let path = getPathFromStartToExit(); // L·∫•y ƒë∆∞·ªùng ch√≠nh t·ª´ player ‚Üí exit
    if (path.length < 4) return; // Qu√° ng·∫Øn th√¨ th√¥i

    // Ch·ªçn nhi·ªÅu ƒëi·ªÉm d·ªçc theo ƒë∆∞·ªùng ch√≠nh ƒë·ªÉ t·∫°o nh√°nh (thay v√¨ ch·ªâ 2 ƒëi·ªÉm)
    let numBranches = Math.max(4, Math.floor(path.length / 6)); // T·∫°o √≠t nh·∫•t 3 nh√°nh
    let branchIndices = [];
    for (let i = 1; i < numBranches; i++) {
        let idx = Math.floor(i * path.length / numBranches);
        branchIndices.push(idx);
    }

    // Duy·ªát qua c√°c ƒëi·ªÉm ng√£ r·∫Ω tr√™n ƒë∆∞·ªùng ch√≠nh
    for (let idx of branchIndices) {
        let p = path[idx];
        // T√¨m c√°c √¥ dead-end xung quanh
        let neighbors = [[0, -1], [1, 0], [0, 1], [-1, 0]];
        neighbors = shuffle(neighbors);

        for (let [dx, dy] of neighbors) {
            let nx = p.x + dx;
            let ny = p.y + dy;

            if (!inBounds(nx, ny)) continue;
            if (maze[ny][nx] !== 0) continue; // Ph·∫£i l√† ƒë∆∞·ªùng gi·∫£
            // Ki·ªÉm tra dead-end: ch·ªâ n·ªëi n·∫øu dead-end (ch·ªâ 1 √¥ m·ªü)
            if (countOpenNeighbors(nx, ny) === 1) {
                // ƒê·ª•c 1 √¥ ƒë·ªÉ n·ªëi v√†o ƒë∆∞·ªùng ch√≠nh
                maze[p.y + dy][p.x + dx] = 0;
                break; // M·ªói v·ªã tr√≠ ch·ªâ n·ªëi 1 nh√°nh
            }
        }
    }
}

function breakWallsNearFakeBranches() {
    let path = getPathFromStartToExit();
    let maxIdx = Math.floor(path.length * 2 / 3); // ∆∞u ti√™n start ‚Üí 2/3 ƒë∆∞·ªùng
    let candidates = [];

    for (let i = 0; i < maxIdx; i++) {
        let p = path[i];
        for (let [dx, dy] of [[0, -1], [1, 0], [0, 1], [-1, 0]]) {
            let nx = p.x + dx;
            let ny = p.y + dy;
            let nnx = p.x + dx * 2;
            let nny = p.y + dy * 2;

            if (!inBounds(nx, ny) || !inBounds(nnx, nny)) continue;
            if (maze[ny][nx] !== 1) continue; // ph·∫£i l√† t∆∞·ªùng
            if (maze[nny][nnx] !== 0) continue; // ph·∫£i l√† nh√°nh gi·∫£/dead-end

            candidates.push({ x: nx, y: ny });
        }
    }

    shuffle(candidates);

    let breakCount = 0;
    for (let j = 0; j < candidates.length; j++) {
        if (breakCount >= 6) break; // ch·ªâ t·ªëi ƒëa 4 √¥
        let c = candidates[j];
        // ‚≠ê Ch·ªâ ƒë·ª•c n·∫øu sau khi ƒë·ª•c kh√¥ng t·∫°o ƒë∆∞·ªùng li·ªÅn k·ªÅ nhi·ªÅu √¥
        if (countOpenNeighbors(c.x, c.y) <= 1) {
            maze[c.y][c.x] = 0;
            breakCount++;
        }
    }
}

    /* ===== DRAW ===== */
  function drawMaze(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // ===== HI·ªÇN TH·ªä TO√ÄN B·ªò MAP =====
    if(revealAll){
        for(let y=0; y<ROWS; y++){
            for(let x=0; x<COLS; x++){
                ctx.fillStyle = maze[y][x]===1 ? "#000" : "#fff";
                ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
            }
        }
    } 
    // ===== CH·∫æ ƒê·ªò ƒê√àN PIN =====
    else {
        ctx.fillStyle = "#000";
        ctx.fillRect(0,0,canvas.width,canvas.height);

        let px = player.x*TILE + TILE/2;
        let py = player.y*TILE + TILE/2;
        let flicker = 0.9 + Math.random()*0.1;
        let lightRadius = TILE*3*flicker;

        ctx.save();
        ctx.beginPath();
        ctx.arc(px, py, lightRadius, 0, Math.PI*2);
        ctx.clip();

        for(let y=0; y<ROWS; y++){
            for(let x=0; x<COLS; x++){
                ctx.fillStyle = maze[y][x]===1 ? "#000" : "#fff";
                ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
            }
        }
        ctx.restore();

        let light = ctx.createRadialGradient(
            px, py, TILE*1.2,
            px, py, lightRadius
        );
        light.addColorStop(0.45,"rgba(255,235,180,0.35)");
        light.addColorStop(1,"rgba(0,0,0,0.8)");
        ctx.fillStyle = light;
        ctx.fillRect(0,0,canvas.width,canvas.height);
    }

    // exit
    ctx.fillStyle="lime";
    ctx.beginPath();
    ctx.arc(exit.x*TILE+TILE/2, exit.y*TILE+TILE/2, TILE/2.5,0,Math.PI*2);
    ctx.fill();

    // player
    let px = player.x*TILE + TILE/2;
    let py = player.y*TILE + TILE/2;
    ctx.fillStyle = "#00ffd5";
    ctx.beginPath();
    ctx.arc(px, py, TILE/2.5,0,Math.PI*2);
    ctx.fill();
}
// ===== CHEAT PC: Ctrl + L =====
document.addEventListener("keydown", e => {
    if (e.ctrlKey && (e.key === "l" || e.key === "L")) {
        e.preventDefault(); // tr√°nh browser focus address bar
        revealAll = !revealAll;
        drawMaze();
        console.log("CHEAT PC: revealAll =", revealAll);
    }
});
// ===== CHEAT MOBILE: 3 tap g√≥c tr√™n tr√°i =====
let cheatTap = 0;
let cheatTimer = null;

canvas.addEventListener("click", e => {
    let rect = canvas.getBoundingClientRect();
    let x = e.clientX - rect.left;
    let y = e.clientY - rect.top;

    if (x < 50 && y < 50) {
        cheatTap++;

        if (cheatTimer) clearTimeout(cheatTimer);
        cheatTimer = setTimeout(() => cheatTap = 0, 600);

        if (cheatTap >= 3) {
            revealAll = !revealAll;
            drawMaze();
            cheatTap = 0;
            console.log("CHEAT MOBILE: revealAll =", revealAll);
        }
    }
});

    /* ===== MOVE LOGIC ===== */
    function availableDirs(x,y){
        let dirs = [];
        if(y>0 && maze[y-1][x]===0) dirs.push([0,-1]);
        if(y<ROWS-1 && maze[y+1][x]===0) dirs.push([0,1]);
        if(x>0 && maze[y][x-1]===0) dirs.push([-1,0]);
        if(x<COLS-1 && maze[y][x+1]===0) dirs.push([1,0]);
        return dirs;
    }

    function move(dx,dy){
        // B·∫Øt ƒë·∫ßu timer khi di chuy·ªÉn l·∫ßn ƒë·∫ßu
        if(!timerStarted){
            startTimer();
            timerStarted = true;
        }
        prevPos = {x:player.x, y:player.y};

        function step(){
            let nx = player.x + dx;
            let ny = player.y + dy;
            if(nx>=0 && nx<COLS && ny>=0 && ny<ROWS && maze[ny][nx]===0){
                player.x = nx;
                player.y = ny;
                drawMaze();

           if(player.x === exit.x && player.y === exit.y){
    revealAll = true;
    drawMaze();

    clearInterval(timerInterval);

    document.getElementById("winMessage").style.display = "block";

    setTimeout(()=>{
        window.location.href = "index.html";
    },15000);

    return;
}
                let dirs = availableDirs(player.x,player.y);
                if(dirs.length === 2){
                    setTimeout(step,70); // auto-move nhanh h∆°n
                }
            }
        }
        step();
    }

    /* ===== INPUT ===== */
    document.addEventListener("keydown", e=>{
        if(e.key==="ArrowUp") move(0,-1);
        if(e.key==="ArrowDown") move(0,1);
        if(e.key==="ArrowLeft") move(-1,0);
        if(e.key==="ArrowRight") move(1,0);
    });

document.getElementById("undoBtn").onclick = () => {
    player.x = 0;   // quay v·ªÅ xu·∫•t ph√°t
    player.y = 0;
    revealAll = false;  // reset ch·∫ø ƒë·ªô ƒë√®n pin n·∫øu ƒëang b·∫≠t
    drawMaze();

    // n·∫øu mu·ªën reset lu√¥n timer
    // clearInterval(timerInterval);
    // timerEl.textContent = "Time: 77 gi√¢y";
    // timerStarted = false;
};

    /* ===== TIMER ===== */
    function startTimer(){
        clearInterval(timerInterval);
        timeLeft = 90;
        timerEl.textContent = "Time: " + timeLeft+" gi√¢y";

        timerInterval = setInterval(()=>{
            timeLeft--;
            timerEl.textContent = "Time: " + timeLeft +" gi√¢y";
            if(timeLeft <= 0){
                clearInterval(timerInterval);
                showEndMessage();
            }
        },1000);
    }

function showEndMessage(){
    revealAll = true;
    drawMaze();

    document.getElementById("loseMessage").style.display = "block";

    setTimeout(()=>{
        document.getElementById("loseMessage").style.display = "none";
        revealAll = false;
        resetGame();
    },15000);
}


 /* ===== MOBILE TOUCH CONTROL ===== */
let touchStartX = 0, touchStartY = 0;
const SWIPE_MIN = 12;

canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    let t = e.touches[0];
    touchStartX = t.clientX;
    touchStartY = t.clientY;
}, { passive: false });

canvas.addEventListener('touchend', e => {
    e.preventDefault();
    let t = e.changedTouches[0];
    let dx = t.clientX - touchStartX;
    let dy = t.clientY - touchStartY;

    if(Math.abs(dx) > Math.abs(dy)){
        if(dx > SWIPE_MIN) move(1,0);
        else if(dx < -SWIPE_MIN) move(-1,0);
    } else {
        if(dy > SWIPE_MIN) move(0,1);
        else if(dy < -SWIPE_MIN) move(0,-1);
    }
}, { passive: false });

    /* ===== RESET GAME ===== */
 function resetGame(){
    revealAll = false;
    initMaze();
    player = {x:0, y:0};
    drawMaze();
    timerEl.textContent = "Time: 90 gi√¢y";
    timerStarted = false;
}

    /* ===== START ===== */
    resetGame();

     /* ===== N√∫t ƒëi·ªÅu khi·ªÉn ===== */
        document.getElementById("undoBtn").onclick = () => {
            player.x = 0;   // Quay v·ªÅ xu·∫•t ph√°t
            player.y = 0;
            revealAll = false;
            drawMaze();
        };

    // C√°c n√∫t di chuy·ªÉn
        document.getElementById("upBtn").onclick = () => {
            move(0, -1);
        };
        document.getElementById("downBtn").onclick = () => {
            move(0, 1);
        };
        document.getElementById("leftBtn").onclick = () => {
            move(-1, 0);
        };
        document.getElementById("rightBtn").onclick = () => {
            move(1, 0);
        };
    </script>
    </body>
    </html>
