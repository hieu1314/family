    <!DOCTYPE html>
    <html lang="en">
    <head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Maze Auto-move Final</title>
    <style>
  html, body {
            margin:0; padding:0; height:100%; overflow:hidden;
            background:#000;
            display:flex;
            flex-direction:column;
            align-items:center;
            justify-content:flex-start;
            color:#fff;
            font-family:sans-serif;
        }
        body { touch-action: none; }
        canvas {
            width: 90vw;
            height: auto;
            max-width: 744px;
        }
        canvas {
            display:block;
            background:#000;
            margin-top:10px;
        }

        #title {
            font-size:24px;
            font-weight:bold;
            margin-top:10px;
        }
        #timer {
            font-size:20px;
            margin-top:4px;
        }
  #winMessage, #loseMessage {
    font-size: 32px;
    font-weight: bold;
    text-align: center;
    text-shadow: 0 0 10px #000;
    background: rgba(0,0,0,0.75);
    padding: 20px 30px;
    border-radius: 14px;
    position: fixed;
    top: 40%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 2000;
}

#winMessage {
    color: #00ff9c;
    text-shadow: 0 0 12px #00ff9c;
}

#loseMessage {
    color: #ff4444;
    text-shadow: 0 0 12px #ff0000;
}

#controls {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    align-items: center;
    gap: 20px; /* kho·∫£ng c√°ch gi·ªØa D-pad v√† n√∫t ‚ü≥ */
    z-index: 1000;
}

/* D-pad 3x3 */
#dpad {
    display: grid;
    grid-template-columns: 60px 60px 60px;
    grid-template-rows: 60px 60px 60px;
    gap: 10px; /* kho·∫£ng tr·ªëng gi·ªØa c√°c n√∫t */
}

/* Kho·∫£ng tr·ªëng ·ªü gi·ªØa */
.center-gap {
    width: 60px;
    height: 60px;
}

/* N√∫t chung */
#dpad button,
#undoBtn {
    width: 60px;
    height: 60px;
    font-size: 30px;
    background-color: #333;
    color: white;
    border: none;
    border-radius: 50%;
    cursor: pointer;
}

#dpad button:hover,
#undoBtn:hover {
    background-color: #555;
}

/* ·∫®n tr√™n PC */
@media (min-width: 769px) {
    #controls {
        display: none;
    }
}
/* PC: ch·ªâ hi·ªán n√∫t ‚ü≥ */
@media (min-width: 769px) {
    #controls {
        display: flex;
        bottom: 20px;
        left: auto;
        right: 20px;
        transform: none;
    }

    #dpad {
        display: none; /* ·∫®n 4 n√∫t di chuy·ªÉn */
    }

    #undoBtn {
        position: static;
    }
}
    </style>
    </head>

    <body>
    <div id="title">H√£y ki√™n nh·∫´n v√† c·∫ßu may</div>
    <div id="timer">Time: 90</div>
    <canvas id="mazeCanvas"></canvas>
  
    <div id="winMessage" style="display:none;">
    üéâ Ch√∫c m·ª´ng h·∫øt m√™ m·ª•i! üéâ
</div>

<div id="loseMessage" style="display:none;">
    üíÄ B·∫°n ƒë√£ h·∫øt th·ªùi gian! üíÄ
</div>
 <!-- C√°c n√∫t di chuy·ªÉn (hi·ªÉn th·ªã ch·ªâ tr√™n mobile) -->
    <div id="controls">
  <div id="dpad">
    <div></div>
    <button id="upBtn">‚Üë</button>
    <div></div>

    <button id="leftBtn">‚Üê</button>
    <div class="center-gap"></div>
    <button id="rightBtn">‚Üí</button>

    <div></div>
    <button id="downBtn">‚Üì</button>
    <div></div>
  </div>

  <button id="undoBtn">‚ü≥</button>
</div>

    <script>
    const canvas = document.getElementById("mazeCanvas");
    const ctx = canvas.getContext("2d");

    const ROWS = 33;
    const COLS = 33;
    const TILE = 24;
    canvas.width = COLS * TILE;
    canvas.height = ROWS * TILE;

    let maze = [];
    let player = {x:0, y:0};
    let exit = {x:COLS-1, y:ROWS-1};
    let prevPos = null;
    let revealExit = true;
    let timerEl = document.getElementById("timer");
    let messageEl = document.getElementById("message");

    let timeLeft = 90; // 90 gi√¢y
    let timerInterval;
let timerStarted = false;
let revealAll = false;

// === CH·ªêNG D√çNH 2 √î ===
function countOpenNeighbors(x,y){
    let c = 0;
    for(let [dx,dy] of [[0,-1],[1,0],[0,1],[-1,0]]){
        let nx = x+dx, ny = y+dy;
        if(inBounds(nx,ny) && maze[ny][nx]===0) c++;
    }
    return c;
}
// === N·ªêI DEAD-END G·∫¶N EXIT V√ÄO NH√ÅNH GI·∫¢ ===
function connectLonelyNearExit(){
    const MAX_DIST = 5; // b√°n k√≠nh quanh exit
    let candidates = [];

    for(let y=exit.y-MAX_DIST; y<=exit.y+MAX_DIST; y++){
        for(let x=exit.x-MAX_DIST; x<=exit.x+MAX_DIST; x++){
            if(!inBounds(x,y)) continue;
            if(maze[y][x]!==0) continue;

            // dead-end th·∫≠t
            if(countOpenNeighbors(x,y) !== 1) continue;

            candidates.push({x,y});
        }
    }

    if(!candidates.length) return;

    let dead = shuffle(candidates)[0];

    // t√¨m fake path g·∫ßn nh·∫•t
    for(let [dx,dy] of shuffle([[0,-1],[1,0],[0,1],[-1,0]])){
        let bx = dead.x + dx*2;
        let by = dead.y + dy*2;

        if(!inBounds(bx,by)) continue;
        if(maze[by][bx]!==0) continue;

        // tr√°nh ƒë·ª•ng exit tr·ª±c ti·∫øp
        if(Math.abs(bx-exit.x)+Math.abs(by-exit.y) <= 1) continue;

        // ch·ªâ n·ªëi n·∫øu kh√¥ng t·∫°o loop
        if(countOpenNeighbors(dead.x+dx, dead.y+dy)===0){
            maze[dead.y+dy][dead.x+dx] = 0;
            break;
        }
    }
}

    /* ===== MAZE GEN ===== */
    function initMaze() {
    // B∆∞·ªõc 1: Kh·ªüi t·∫°o m√™ cung ban ƒë·∫ßu
    maze = Array.from({ length: ROWS }, () => Array(COLS).fill(1));

  
   exit = getFixedExit();
    player = {x:0,y:0};

    carveMainPath(0,0);
addDeadEnds();

// fake branch
let path = getPathFromStartToExit();
let a = path[5];
if(a) createFakeDeadEnd(a.x, a.y, 6);
let b = path[20 + Math.floor(Math.random()*10)];
if(b) createFakeDeadEnd(b.x, b.y, 7);

// üî• QUAN TR·ªåNG
sealExit();
connectLonelyNearExit();
ensureExitReachable_FarthestFromExit();
     // ƒë·∫£m b·∫£o l·ªëi ra cho player
    maze[0][0] = 0;
    maze[0][1] = 0;
    maze[1][0] = 0;

    maze[exit.y][exit.x] = 0;

    drawMaze();
}
 function getFixedExit(){
    return {
        x: COLS - 3, // c√°ch t∆∞·ªùng ph·∫£i 2 √¥
        y: ROWS - 3  // c√°ch t∆∞·ªùng d∆∞·ªõi 2 √¥
    };
}
function shuffle(arr){
    return arr.sort(()=>Math.random()-0.5);
}

function inBounds(x,y){
    return x>=0 && y>=0 && x<COLS && y<ROWS;
}
function carveMainPath(x, y, depth = 0){
    maze[y][x] = 0;

    let dirs = shuffle([
        [0,-1],[1,0],[0,1],[-1,0]
    ]);

    for(let [dx,dy] of dirs){
        let nx = x + dx*2;
        let ny = y + dy*2;

        if(!inBounds(nx,ny)) continue;
        if(maze[ny][nx] === 0) continue;

        // ‚ùå tr√°nh ƒë√†o th·∫≥ng v·ªÅ exit s·ªõm
        let distToExit = Math.abs(nx-exit.x)+Math.abs(ny-exit.y);
        if(distToExit < 10 && depth < 20) continue;

        maze[y+dy][x+dx] = 0;
        carveMainPath(nx,ny,depth+1);
    }
}
function carveDeadEnd(x,y,length=9){
    let cx=x, cy=y;
    let dir = shuffle([[0,-1],[1,0],[0,1],[-1,0]])[0];

    for(let i=0;i<length;i++){
        let nx=cx+dir[0]*2;
        let ny=cy+dir[1]*2;

        if(!inBounds(nx,ny) || maze[ny][nx]===0) break;
        if(countOpenNeighbors(nx,ny) > 1) break; // ‚≠ê CH·ªêNG D√çNH

        maze[cy+dir[1]][cx+dir[0]] = 0;
        maze[ny][nx] = 0;

        cx=nx; cy=ny;
    }
}

function addDeadEnds(){
    for(let y=1;y<ROWS;y+=2){
        for(let x=1;x<COLS;x+=2){
            if(maze[y][x]===0 && Math.random()<0.35){
                carveDeadEnd(x,y,9+Math.floor(Math.random()*4));
            }
        }
    }
}
function sealExit() {
    let ex = exit.x;
    let ey = exit.y;
    const neighbors = [[0,-1], [1,0], [0,1], [-1,0]];

    // ƒê·∫∑t t∆∞·ªùng 1 √¥ quanh exit
    for (let [dx, dy] of neighbors) {
        let x = ex + dx;
        let y = ey + dy;
        if (inBounds(x, y)) maze[y][x] = 1;
    }

    // T·∫°o l·ªëi ch√≠nh t·ª´ ƒë∆∞·ªùng ch√≠nh ƒë·∫øn exit (gi·ªØ choke point)
    let dirs = shuffle(neighbors);
    let mainDir = null;
    for (let [dx, dy] of dirs) {
        for (let i = 1; i <= 12; i++) {
            let nx = ex + dx * i;
            let ny = ey + dy * i;
            if (inBounds(nx, ny) && maze[ny][nx] === 0) {
                for (let j = i; j >= 2; j--) {
                    maze[ey + dy * j][ex + dx * j] = 0;
                }
                maze[ey + dy][ex + dx] = 0;
                maze[ey][ex] = 0;
                mainDir = [dx, dy];
                break;
            }
        }
        if (mainDir) break;
    }

    maze[exit.y][exit.x] = 0; // B·∫£o hi·ªÉm kh√¥ng bao gi·ªù b√≠t exit
}

function createFakeDeadEnd(sx, sy, length){
    const dirs = shuffle([[0,-1],[1,0],[0,1],[-1,0]]);

    for(let [dx,dy] of dirs){
        let bx = sx + dx*2;
        let by = sy + dy*2;

        if(!inBounds(bx,by)) continue;
        if(maze[by][bx]===0) continue;
        if(countOpenNeighbors(bx,by)>0) continue;

        // ‚≠ê ch·ªâ 1 choke point
        maze[sy+dy][sx+dx] = 0;
        maze[by][bx] = 0;

        let cx=bx, cy=by;
        for(let i=0;i<length;i++){
            let d2 = shuffle([[0,-1],[1,0],[0,1],[-1,0]])[0];
            let nx=cx+d2[0]*2;
            let ny=cy+d2[1]*2;

            if(!inBounds(nx,ny)) break;
            if(maze[ny][nx]===0) break;
            if(countOpenNeighbors(nx,ny)>1) break;

            maze[cy+d2[1]][cx+d2[0]] = 0;
            maze[ny][nx] = 0;
            cx=nx; cy=ny;
        }
        break; // ‚ùó ch·ªâ 1 nh√°nh
    }
}

// H√†m l·∫•y m·∫£ng c√°c √¥ ƒë∆∞·ªùng ch√≠nh t·ª´ player ‚Üí exit
function getPathFromStartToExit(){
    // BFS ho·∫∑c DFS ƒë·ªÉ t√¨m 1 ƒë∆∞·ªùng ƒë∆°n gi·∫£n t·ª´ start ‚Üí exit
    let queue = [{x:0,y:0,path:[{x:0,y:0}]}];
    let visited = Array.from({length:ROWS},()=>Array(COLS).fill(false));
    visited[0][0]=true;

    while(queue.length){
        let curr = queue.shift();
        if(curr.x===exit.x && curr.y===exit.y) return curr.path;

        for(let [dx,dy] of [[0,-1],[1,0],[0,1],[-1,0]]){
            let nx = curr.x + dx;
            let ny = curr.y + dy;
            if(!inBounds(nx,ny)) continue;
            if(maze[ny][nx]!==0) continue;
            if(visited[ny][nx]) continue;
            visited[ny][nx]=true;
            queue.push({x:nx,y:ny,path:[...curr.path,{x:nx,y:ny}]});
        }
    }
    return [{x:0,y:0}]; // fallback
}

function getReachableFromPlayer(){
    let visited = Array.from({length: ROWS}, () => Array(COLS).fill(false));
    let stack = [{x:0,y:0}];
    visited[0][0] = true;

    while(stack.length){
        let {x,y} = stack.pop();
        for(let [dx,dy] of [[0,-1],[1,0],[0,1],[-1,0]]){
            let nx = x+dx, ny = y+dy;
            if(
                inBounds(nx,ny) &&
                !visited[ny][nx] &&
                maze[ny][nx] === 0
            ){
                visited[ny][nx] = true;
                stack.push({x:nx,y:ny});
            }
        }
    }
    return visited;
}
function ensureExitReachable_FarthestFromExit(){
    let reachable = getReachableFromPlayer();

    // ‚úÖ ƒê√£ ƒëi ƒë∆∞·ª£c r·ªìi ‚Üí th√¥i
    if(reachable[exit.y][exit.x]) return;

    // ‚úÖ Nh√¨n / ƒëi th·∫≥ng ƒë∆∞·ª£c ‚Üí th√¥i
    if(hasClearPathToExit()) return;

    let best = null;
    let bestDist = -1;

    for(let y=1; y<ROWS-1; y++){
        for(let x=1; x<COLS-1; x++){
            if(maze[y][x] !== 1) continue;

            let hasReachable = false;
            let hasUnreachable = false;

            for(let [dx,dy] of [[0,-1],[1,0],[0,1],[-1,0]]){
                let nx = x+dx, ny = y+dy;
                if(!inBounds(nx,ny)) continue;
                if(maze[ny][nx] !== 0) continue;

                if(reachable[ny][nx]) hasReachable = true;
                else hasUnreachable = true;
            }

            if(hasReachable && hasUnreachable){
                let dist = Math.abs(x-exit.x) + Math.abs(y-exit.y);
                if(dist > bestDist){
                    bestDist = dist;
                    best = {x,y};
                }
            }
        }
    }

    if(best){
        maze[best.y][best.x] = 0; // ‚≠ê ch·ªâ l√∫c TH·∫¨T S·ª∞ C·∫¶N
    }
}

function hasClearPathToExit(){
    let x = 0, y = 0;

    // ƒëi ngang tr∆∞·ªõc
    let stepX = exit.x > x ? 1 : -1;
    while(x !== exit.x){
        if(maze[y][x] === 1) return false;
        x += stepX;
    }

    // r·ªìi ƒëi d·ªçc
    let stepY = exit.y > y ? 1 : -1;
    while(y !== exit.y){
        if(maze[y][x] === 1) return false;
        y += stepY;
    }

    return true;
}

    /* ===== DRAW ===== */
  function drawMaze(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // ===== HI·ªÇN TH·ªä TO√ÄN B·ªò MAP =====
    if(revealAll){
        for(let y=0; y<ROWS; y++){
            for(let x=0; x<COLS; x++){
                ctx.fillStyle = maze[y][x]===1 ? "#000" : "#fff";
                ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
            }
        }
    } 
    // ===== CH·∫æ ƒê·ªò ƒê√àN PIN =====
    else {
        ctx.fillStyle = "#000";
        ctx.fillRect(0,0,canvas.width,canvas.height);

        let px = player.x*TILE + TILE/2;
        let py = player.y*TILE + TILE/2;
        let flicker = 0.9 + Math.random()*0.1;
        let lightRadius = TILE*3*flicker;

        ctx.save();
        ctx.beginPath();
        ctx.arc(px, py, lightRadius, 0, Math.PI*2);
        ctx.clip();

        for(let y=0; y<ROWS; y++){
            for(let x=0; x<COLS; x++){
                ctx.fillStyle = maze[y][x]===1 ? "#000" : "#fff";
                ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
            }
        }
        ctx.restore();

        let light = ctx.createRadialGradient(
            px, py, TILE*1.2,
            px, py, lightRadius
        );
        light.addColorStop(0.45,"rgba(255,235,180,0.35)");
        light.addColorStop(1,"rgba(0,0,0,0.8)");
        ctx.fillStyle = light;
        ctx.fillRect(0,0,canvas.width,canvas.height);
    }

    // exit
    ctx.fillStyle="lime";
    ctx.beginPath();
    ctx.arc(exit.x*TILE+TILE/2, exit.y*TILE+TILE/2, TILE/2.5,0,Math.PI*2);
    ctx.fill();

    // player
    let px = player.x*TILE + TILE/2;
    let py = player.y*TILE + TILE/2;
    ctx.fillStyle = "#00ffd5";
    ctx.beginPath();
    ctx.arc(px, py, TILE/2.5,0,Math.PI*2);
    ctx.fill();
}
    /* ===== MOVE LOGIC ===== */
    function availableDirs(x,y){
        let dirs = [];
        if(y>0 && maze[y-1][x]===0) dirs.push([0,-1]);
        if(y<ROWS-1 && maze[y+1][x]===0) dirs.push([0,1]);
        if(x>0 && maze[y][x-1]===0) dirs.push([-1,0]);
        if(x<COLS-1 && maze[y][x+1]===0) dirs.push([1,0]);
        return dirs;
    }

    function move(dx,dy){
        // B·∫Øt ƒë·∫ßu timer khi di chuy·ªÉn l·∫ßn ƒë·∫ßu
        if(!timerStarted){
            startTimer();
            timerStarted = true;
        }
        prevPos = {x:player.x, y:player.y};

        function step(){
            let nx = player.x + dx;
            let ny = player.y + dy;
            if(nx>=0 && nx<COLS && ny>=0 && ny<ROWS && maze[ny][nx]===0){
                player.x = nx;
                player.y = ny;
                drawMaze();

           if(player.x === exit.x && player.y === exit.y){
    revealAll = true;
    drawMaze();

    clearInterval(timerInterval);

    document.getElementById("winMessage").style.display = "block";

    setTimeout(()=>{
        window.location.href = "index.html";
    },15000);

    return;
}
                let dirs = availableDirs(player.x,player.y);
                if(dirs.length === 2){
                    setTimeout(step,70); // auto-move nhanh h∆°n
                }
            }
        }
        step();
    }

    /* ===== INPUT ===== */
    document.addEventListener("keydown", e=>{
        if(e.key==="ArrowUp") move(0,-1);
        if(e.key==="ArrowDown") move(0,1);
        if(e.key==="ArrowLeft") move(-1,0);
        if(e.key==="ArrowRight") move(1,0);
    });

document.getElementById("undoBtn").onclick = () => {
    player.x = 0;   // quay v·ªÅ xu·∫•t ph√°t
    player.y = 0;
    revealAll = false;  // reset ch·∫ø ƒë·ªô ƒë√®n pin n·∫øu ƒëang b·∫≠t
    drawMaze();

    // n·∫øu mu·ªën reset lu√¥n timer
    // clearInterval(timerInterval);
    // timerEl.textContent = "Time: 77 gi√¢y";
    // timerStarted = false;
};

    /* ===== TIMER ===== */
    function startTimer(){
        clearInterval(timerInterval);
        timeLeft = 90;
        timerEl.textContent = "Time: " + timeLeft+" gi√¢y";

        timerInterval = setInterval(()=>{
            timeLeft--;
            timerEl.textContent = "Time: " + timeLeft +" gi√¢y";
            if(timeLeft <= 0){
                clearInterval(timerInterval);
                showEndMessage();
            }
        },1000);
    }

function showEndMessage(){
    revealAll = true;
    drawMaze();

    document.getElementById("loseMessage").style.display = "block";

    setTimeout(()=>{
        document.getElementById("loseMessage").style.display = "none";
        revealAll = false;
        resetGame();
    },15000);
}


 /* ===== MOBILE TOUCH CONTROL ===== */
let touchStartX = 0, touchStartY = 0;
const SWIPE_MIN = 12;

canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    let t = e.touches[0];
    touchStartX = t.clientX;
    touchStartY = t.clientY;
}, { passive: false });

canvas.addEventListener('touchend', e => {
    e.preventDefault();
    let t = e.changedTouches[0];
    let dx = t.clientX - touchStartX;
    let dy = t.clientY - touchStartY;

    if(Math.abs(dx) > Math.abs(dy)){
        if(dx > SWIPE_MIN) move(1,0);
        else if(dx < -SWIPE_MIN) move(-1,0);
    } else {
        if(dy > SWIPE_MIN) move(0,1);
        else if(dy < -SWIPE_MIN) move(0,-1);
    }
}, { passive: false });

    /* ===== RESET GAME ===== */
 function resetGame(){
    revealAll = false;
    initMaze();
    player = {x:0, y:0};
    drawMaze();
    timerEl.textContent = "Time: 90 gi√¢y";
    timerStarted = false;
}

    /* ===== START ===== */
    resetGame();

     /* ===== N√∫t ƒëi·ªÅu khi·ªÉn ===== */
        document.getElementById("undoBtn").onclick = () => {
            player.x = 0;   // Quay v·ªÅ xu·∫•t ph√°t
            player.y = 0;
            revealAll = false;
            drawMaze();
        };

    // C√°c n√∫t di chuy·ªÉn
        document.getElementById("upBtn").onclick = () => {
            move(0, -1);
        };
        document.getElementById("downBtn").onclick = () => {
            move(0, 1);
        };
        document.getElementById("leftBtn").onclick = () => {
            move(-1, 0);
        };
        document.getElementById("rightBtn").onclick = () => {
            move(1, 0);
        };
    </script>
    </body>
    </html>
